# Application description for Iperf, provided for convenience for users of OMF
# 5.3.
# Please refer to iperf.rb for the current, up-to-date description.
#
# Copyright 2012-2013 National ICT Australia (NICTA)
#
# This software may be used and distributed solely under the terms of
# the MIT license (License).  You should find a copy of the License in
# COPYING or at http://opensource.org/licenses/MIT. By downloading or
# using this software you accept the terms and the liability disclaimer
# in the License.
#
defApplication('oml:app:iperf', 'iperf') do |app|

  app.version(2, 9, -0) # This is the version of the OML instrumentation, not the base Iperf
  app.shortDescription = 'Iperf traffic generator and bandwidth measurement tool'
  app.description = %{Iperf is a traffic generator and bandwidth measurement
tool. It provides generators producing various forms of packet streams and port
for sending these packets via various transports, such as TCP and UDP.
  }
  app.path = "@bindir@/iperf"

  app.defProperty('interval', 'pause n seconds between periodic bandwidth reports', ?i,
		  :type => :float)
  app.defProperty('len', 'set length read/write buffer to n (default 8 KB)', ?l,
		  :type => :integer)
  app.defProperty('print_mss', 'print TCP maximum segment size (MTU - TCP/IP header)', ?m,
		  :type => :boolean)
  app.defProperty('output', 'output the report or error message to this specified file', ?o,
		  :type => :string)
  app.defProperty('port', 'set server port to listen on/connect to to n (default 5001)', ?p,
		  :type => :integer)
  app.defProperty('udp', 'use UDP rather than TCP', ?u,
		  :type => :boolean,
		  :order => 2)
  app.defProperty('window', 'TCP window size (socket buffer size)', ?w,
		  :type => :integer)
  app.defProperty('bind', 'bind to <host>, an interface or multicast address', ?B,
		  :type => :string)
  app.defProperty('compatibility', 'for use with older versions does not sent extra msgs', ?C,
		  :type => :boolean)
  app.defProperty('mss', 'set TCP maximum segment size (MTU - 40 bytes)', ?M,
		  :type => :integer)
  app.defProperty('nodelay', 'set TCP no delay, disabling Nagle\'s Algorithm', ?N,
		  :type => :boolean)
  app.defProperty('IPv6Version', 'set the domain to IPv6', ?V,
		  :type => :boolean)
  app.defProperty('reportexclude', '[CDMSV]   exclude C(connection) D(data) M(multicast) S(settings) V(server) reports', ?x,
		  :type => :string)
  app.defProperty('reportstyle', 'C or c for CSV report, O or o for OML', ?y,
		  :type => :string)

  app.defProperty('server', 'run in server mode', ?s,
		  :type => :boolean)

  app.defProperty('bandwidth', 'set target bandwidth to n bits/sec (default 1 Mbit/sec)', ?b,
		  :type => :string)
  app.defProperty('client', 'run in client mode, connecting to <host>', ?c,
		  :type => :string,
		  :order => 1)
  app.defProperty('dualtest', 'do a bidirectional test simultaneously', ?d,
		  :type => :boolean)
  app.defProperty('num', 'number of bytes to transmit (instead of -t)', ?n,
		  :type => :integer)
  app.defProperty('tradeoff', 'do a bidirectional test individually', ?r,
		  :type => :boolean)
  app.defProperty('time', 'time in seconds to transmit for (default 10 secs)', ?t,
		  :type => :integer)
  app.defProperty('fileinput', 'input the data to be transmitted from a file', ?F,
		  :type => :string)
  app.defProperty('stdin', 'input the data to be transmitted from stdin', ?I,
		  :type => :boolean)
  app.defProperty('listenport', 'port to recieve bidirectional tests back on', ?L,
		  :type => :integer)
  app.defProperty('parallel', 'number of parallel client threads to run', ?P,
		  :type => :integer)
  app.defProperty('ttl', 'time-to-live, for multicast (default 1)', ?T,
		  :type => :integer)
  app.defProperty('linux-congestion', 'set TCP congestion control algorithm (Linux only)', ?Z,
		  :type => :boolean)

  app.defMeasurement("application"){ |m|
    m.defMetric('pid', :guid, 'Main process globally unique identifier')
    m.defMetric('version', :string, 'Iperf version')
    m.defMetric('cmdline', :string, 'Iperf invocation command line')
    m.defMetric('starttime_s', :integer, 'Time the application was received (s)')
    m.defMetric('starttime_us', :integer, 'Time the application was received (us)')
  }

  app.defMeasurement("settings"){ |m|
    m.defMetric('pid', :guid, 'Main process globally unique identifier')
    m.defMetric('server_mode', :integer, '1 if in server mode, 0 otherwise')
    m.defMetric('bind_address', :string, 'Address to bind')
    m.defMetric('multicast', :integer, '1 if listening to a Multicast group')
    m.defMetric('multicast_ttl', :integer, 'Multicast TTL if relevant')
    m.defMetric('transport_protocol', :integer, 'Transport protocol (IANA number)')
    m.defMetric('window_size', :integer, 'TCP window size')
    m.defMetric('buffer_size', :integer, 'UDP buffer size')
  }

  app.defMeasurement("connection"){ |m|
    m.defMetric('pid', :guid, 'Main process globally unique identifier')
    m.defMetric('connection_id', :guid, 'Connection globally unique identifier')
    m.defMetric('local_address', :string, 'Local network address')
    m.defMetric('local_port', :integer, 'Local port')
    m.defMetric('remote_address', :string, 'Remote network address')
    m.defMetric('remote_port', :integer, 'Remote port')
  }

  app.defMeasurement("transfer"){ |m|
    m.defMetric('pid', :guid, 'Main process globally unique identifier')
    m.defMetric('connection_id', :guid, 'Connection globally unique identifier')
    m.defMetric('begin_interval', :float, 'Start of the averaging interval (Iperf timestamp)')
    m.defMetric('end_interval', :float, 'End of the averaging interval (Iperf timestamp)')
    m.defMetric('size', :uint32, 'Amount of transmitted data [Bytes]')
  }

  app.defMeasurement("losses"){ |m|
    m.defMetric('pid', :guid, 'Main process globally unique identifier')
    m.defMetric('connection_id', :guid, 'Connection globally unique identifier')
    m.defMetric('begin_interval', :float, 'Start of the averaging interval (Iperf timestamp)')
    m.defMetric('end_interval', :float, 'End of the averaging interval (Iperf timestamp)')
    m.defMetric('total_datagrams', :integer, 'Total number of datagrams')
    m.defMetric('lost_datagrams', :integer, 'Number of lost datagrams')
  }

  app.defMeasurement("jitter"){ |m|
    m.defMetric('pid', :guid, 'Main process globally unique identifier')
    m.defMetric('connection_id', :guid, 'Connection globally unique identifier')
    m.defMetric('begin_interval', :float, 'Start of the averaging interval (Iperf timestamp)')
    m.defMetric('end_interval', :float, 'End of the averaging interval (Iperf timestamp)')
    m.defMetric('jitter', :float, 'Average jitter [ms]')
  }

  app.defMeasurement("packets"){ |m|
    m.defMetric('pid', :guid, 'Main process globally unique identifier')
    m.defMetric('connection_id', :guid, 'Connection globally unique identifier')
    m.defMetric('packet_id', :integer, 'Packet sequence number for datagram-oriented protocols')
    m.defMetric('packet_size', :integer, 'Packet size')
    m.defMetric('packet_time_s', :integer, 'Time the packet was processed (s)')
    m.defMetric('packet_time_us', :integer, 'Time the packet was processed (us)')
    m.defMetric('packet_sent_time_s', :integer, 'Time the packet was sent (s) for datagram-oriented protocols')
    m.defMetric('packet_sent_time_us', :integer, 'Time the packet was sent (us) for datagram-oriented protocols')
  }

end

# Local Variables:
# mode:ruby
# End:
# vim: ft=ruby:sw=2
