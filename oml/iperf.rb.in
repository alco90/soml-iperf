#
# Copyright 2012-2014 National ICT Australia (NICTA)
#
# This software may be used and distributed solely under the terms of
# the MIT license (License).  You should find a copy of the License in
# COPYING or at http://opensource.org/licenses/MIT. By downloading or
# using this software you accept the terms and the liability disclaimer
# in the License.
#
defApplication('oml:app:iperf', 'iperf') do |app|

  app.version(2, 9, -0) # This is the version of the OML instrumentation, not the base Iperf
  app.shortDescription = 'Iperf traffic generator and bandwidth measurement tool'
  app.description = %{Iperf is a traffic generator and bandwidth measurement
tool. It provides generators producing various forms of packet streams and port
for sending these packets via various transports, such as TCP and UDP.
  }
  app.path = "@bindir@/iperf"

  app.defProperty('interval', 'pause n seconds between periodic bandwidth reports', '-i',
		  :type => :double, :unit => "second", :default => '1.')
  app.defProperty('len', 'set length read/write buffer to n (default 8 KB)', '-l',
		  :type => :integer, :unit => "KiBytes")
  app.defProperty('print_mss', 'print TCP maximum segment size (MTU - TCP/IP header)', '-m',
		  :type => :boolean)
  app.defProperty('output', 'output the report or error message to this specified file', '-o',
		  :type => :string)
  app.defProperty('port', 'set server port to listen on/connect to to n (default 5001)', '-p',
		  :type => :integer)
  app.defProperty('udp', 'use UDP rather than TCP', '-u',
		  :type => :boolean,
		  :order => 2)
  app.defProperty('window', 'TCP window size (socket buffer size)', '-w',
		  :type => :integer, :unit => "Bytes")
  app.defProperty('bind', 'bind to <host>, an interface or multicast address', '-B',
		  :type => :string)
  app.defProperty('compatibility', 'for use with older versions does not sent extra msgs', '-C',
		  :type => :boolean)
  app.defProperty('mss', 'set TCP maximum segment size (MTU - 40 bytes)', '-M',
		  :type => :integer, :unit => "Bytes")
  app.defProperty('nodelay', 'set TCP no delay, disabling Nagle\'s Algorithm', '-N',
		  :type => :boolean)
  app.defProperty('IPv6Version', 'set the domain to IPv6', '-V',
		  :type => :boolean)
  app.defProperty('reportexclude', 'exclude C(connection) D(data) M(multicast) S(settings) V(server) reports', '-x',
		  :type => :string, :unit => "[CDMSV]")
  app.defProperty('reportstyle', 'C or c for CSV report, O or o for OML', '-y',
		  :type => :string, :unit => "[CcOo]", :default => "o") # Use OML reporting by default

  app.defProperty('server', 'run in server mode', '-s',
		  :type => :boolean)

  app.defProperty('bandwidth', 'set target bandwidth to n bits/sec (default 1 Mbit/sec)', '-b',
		  :type => :string, :unit => "Mbps")
  app.defProperty('client', 'run in client mode, connecting to <host>', '-c',
		  :type => :string,
		  :order => 1)
  app.defProperty('dualtest', 'do a bidirectional test simultaneously', '-d',
		  :type => :boolean)
  app.defProperty('num', 'number of bytes to transmit (instead of -t)', '-n',
		  :type => :integer, :unit => "Bytes")
  app.defProperty('tradeoff', 'do a bidirectional test individually', '-r',
		  :type => :boolean)
  app.defProperty('time', 'time in seconds to transmit for (default 10 secs)', '-t',
		  :type => :integer, :unit => "second")
  app.defProperty('fileinput', 'input the data to be transmitted from a file', '-F',
		  :type => :string)
  app.defProperty('stdin', 'input the data to be transmitted from stdin', '-I',
		  :type => :boolean)
  app.defProperty('listenport', 'port to recieve bidirectional tests back on', '-L',
		  :type => :integer)
  app.defProperty('parallel', 'number of parallel client threads to run', '-P',
		  :type => :integer)
  app.defProperty('ttl', 'time-to-live, for multicast (default 1)', '-T',
		  :type => :integer,
		  :default => 1)
  app.defProperty('linux-congestion', 'set TCP congestion control algorithm (Linux only)', '-Z',
		  :type => :boolean)

  app.defMeasurement("application"){ |m|
    m.defMetric('pid', :integer, 'Main process identifier', [['MD:Iperf','MD:hasMetricAttributes', 'MD:id'],['MD:id','MD:MeasurementDataValue','%value%']])
    m.defMetric('version', :string, 'Iperf version',[['MD:Iperf','MD:hasMeasurementData','MD:ToolVersion'],['MD:ToolVersion','MD:ToolVersionValue','%value%']])
    m.defMetric('cmdline', :string, 'Iperf invocation command line',[['MD:Iperf','MD:hasMeasurementData','MD:Arguments'],['MD:Arguments','MD:ArgumentsValue','%value%']])
    m.defMetric('starttime_s', :integer, 'Time the application was received (s)',[['MD:Iperf','MD:hasMeasurementData','MD:Arguments'],['MD:Arguments','MD:ArgumentsValue','%value%']])
    m.defMetric('starttime_us', :integer, 'Time the application was received (us)',[['MD:Iperf','MD:hasMeasurementData','MD:Arguments'],['MD:Arguments','MD:ArgumentsValue','%value%']])
  }

  app.defMeasurement("settings"){ |m|
    m.defMetric('pid', :integer, 'Main process identifier', [['MD:Iperf','MD:hasMetricAttributes', 'MD:id'],['MD:id','MD:MeasurementDataValue','%value%']])
    m.defMetric('server_mode', :integer, '1 if in server mode, 0 otherwise')
    m.defMetric('bind_address', :string, 'Address to bind',[['MD:Iperf','MD:hasMetricAttributes','MD:BindIP'],['MD:BindIP','MD:MeasurementDataValue','%value%'],['MD:BindIP','MD:defaultUnit','MU:ipv4dotted']])
    m.defMetric('multicast', :integer, '1 if listening to a Multicast group',[['MD:Iperf','MD:hasMeasurementData','MD:isListeningMulticast'],['MD:isListeningMulticast','MD:MeasurementDataValue','%value%']])
    m.defMetric('multicast_ttl', :integer, 'Multicast TTL if relevant',[['MD:Iperf','MD:hasMetricAttributes','MD:FinalTtlMeasurement'],['MD:FinalTtlMeasurement','MD:MeasurementDataValue','%value%']])
    m.defMetric('transport_protocol', :integer, 'Transport protocol (IANA number)', [['MD:Iperf','MD:hasMetricAttributes','MGC:TransportProtocol'],['MGC:TransportProtocol','MGC:protocolNumber','%value%']])
    m.defMetric('window_size', :integer, 'TCP window size',[['MD:Iperf','MD:hasMeasurementData','MD:Arguments'],['MD:Arguments','MD:ArgumentsValue','%value%']])
    m.defMetric('buffer_size', :integer, 'UDP buffer size',[['MD:Iperf','MD:hasMeasurementData','MD:Arguments'],['MD:Arguments','MD:ArgumentsValue','%value%']])
  }

  app.defMeasurement("connection"){ |m|
    m.defMetric('pid', :integer, 'Main process identifier', [['MD:Iperf','MD:hasMetricAttributes', 'MD:id'],['MD:id','MD:MeasurementDataValue','%value%']])
    m.defMetric('connection_id', :integer, 'Connection identifier (socket)')
    m.defMetric('local_address', :string, 'Local network address', [['MD:Iperf','MD:hasMetricAttributes','MD:SourceIP'],['MD:SourceIP','MD:SourceIPValue','%value%'],['MD:SourceIP','MD:defaultUnit','MU:ipv4dotted']])
    m.defMetric('local_port', :integer, 'Local port', [['MD:Iperf','MD:hasMetricAttributes','MD:SourcePort'],['MD:SourcePort','MD:SourcePortValue', '%value%']])
    m.defMetric('remote_address', :string, 'Remote network address', [['MD:Iperf','MD:hasMetricAttributes','MD:DestinationIP'],['MD:DestinationIP','MD:DestinationIPValue','%value%'],['MD:DestinationIP','MD:defaultUnit','MU:ipv4dotted']])
    m.defMetric('remote_port', :integer, 'Remote port', [['MD:Iperf','MD:hasMetricAttributes','MD:DestinationPort'],['MD:DestinationPort','MD:DestinationPortValue', '%value%']])
  }

  app.defMeasurement("transfer"){ |m|
    m.defMetric('pid', :integer, 'Main process identifier', [['MD:Iperf','MD:hasMetricAttributes', 'MD:id'],['MD:id','MD:MeasurementDataValue','%value%']])
    m.defMetric('connection_id', :integer, 'Connection identifier (socket)')
    m.defMetric('begin_interval', :double, 'Start of the averaging interval (Iperf timestamp)', [['MD:Iperf','MD:hasMetricAttributes','MGC:TimeStamp'],['MGC:TimeStamp','MGC:startTime','%value%'],['MGC:TimeStamp','MD:defaultUnit','MU:second']])
    m.defMetric('end_interval', :double, 'End of the averaging interval (Iperf timestamp)', [['MD:Iperf','MD:hasMetricAttributes','MGC:TimeStamp'],['MGC:TimeStamp','MGC:endTime','%value%'],['MGC:TimeStamp','MD:defaultUnit','MU:second']])
    m.defMetric('size', :uint64, 'Amount of transmitted data [Bytes]')
    m.defMetric('capacity', :double, 'Capacity of the link [Bytes per second]', [['MD:Iperf','MD:hasMetricAttributes', 'MD:CapacityMeasurement'],['MD:CapacityMeasurement','MD:CapacityMeasurementValue','%value%'],['MD:CapacityMeasurement','MD:defaultUnit','MU:Bytepersec']])
  }

  app.defMeasurement("losses"){ |m|
    m.defMetric('pid', :integer, 'Main process identifier', [['MD:Iperf','MD:hasMetricAttributes', 'MD:id'],['MD:id','MD:MeasurementDataValue','%value%']])
    m.defMetric('connection_id', :integer, 'Connection identifier (socket)')
    m.defMetric('begin_interval', :double, 'Start of the averaging interval (Iperf timestamp)', [['MD:Iperf','MD:hasMetricAttributes','MGC:TimeStamp'],['MGC:TimeStamp','MGC:startTime','%value%'],['MGC:TimeStamp','MD:defaultUnit','MU:second']])
    m.defMetric('end_interval', :double, 'End of the averaging interval (Iperf timestamp)', [['MD:Iperf','MD:hasMetricAttributes','MGC:TimeStamp'],['MGC:TimeStamp','MGC:endTime','%value%'],['MGC:TimeStamp','MD:defaultUnit','MU:second']])
    m.defMetric('total_datagrams', :integer, 'Total number of datagrams', [['MD:Iperf','MD:hasMeasurementData','MD:PacketsCount'],['MD:PacketsCount','MD:PacketsCountValue','%value%']])
    m.defMetric('lost_datagrams', :integer, 'Number of lost datagrams', [['MD:Iperf','MD:hasMeasurementData','MD:ErrorsRate'],['MD:ErrorsRate','MD:ErrorsRateValue','%value%']])
  }

  app.defMeasurement("jitter"){ |m|
    m.defMetric('pid', :integer, 'Main process identifier', [['MD:Iperf','MD:hasMetricAttributes', 'MD:id'],['MD:id','MD:MeasurementDataValue','%value%']])
    m.defMetric('connection_id', :integer, 'Connection identifier (socket)')
    m.defMetric('begin_interval', :double, 'Start of the averaging interval (Iperf timestamp)', [['MD:Iperf','MD:hasMetricAttributes','MGC:TimeStamp'],['MGC:TimeStamp','MGC:startTime','%value%'],['MGC:TimeStamp','MD:defaultUnit','MU:second']])
    m.defMetric('end_interval', :double, 'End of the averaging interval (Iperf timestamp)', [['MD:Iperf','MD:hasMetricAttributes','MGC:TimeStamp'],['MGC:TimeStamp','MGC:endTime','%value%'],['MGC:TimeStamp','MD:defaultUnit','MU:second']])
    m.defMetric('jitter', :double, 'Average jitter [ms]', [['MD:Iperf','MD:hasMetricAttributes','MD:DelayVariationMeasurement'],['MD:DelayVariationMeasurement','MD:DelayVariationMeasurementValue','%value%'],['MD:DelayVariationMeasurement','MD:defaultUnit','MU:millisecond']])
  }

  app.defMeasurement("packets"){ |m|
    m.defMetric('pid', :integer, 'Main process identifier', [['MD:Iperf','MD:hasMetricAttributes', 'MD:id'],['MD:id','MD:MeasurementDataValue','%value%']])
    m.defMetric('connection_id', :integer, 'Connection identifier (socket)')
    m.defMetric('packet_id', :integer, 'Packet sequence number for datagram-oriented protocols',[['MD:Iperf','MD:hasMeasurementData','MD:PacketIdentifier'],['MD:PacketIdentifier','MD:PacketIdentifierValue','%value%']])
    m.defMetric('packet_size', :integer, 'Packet size', [['MD:Iperf','MD:hasMeasurementData', 'MD:PacketSize'],['MD:PacketSize','MD:PacketSizeValue','%value%'],['MD:PacketSize','MD:defaultUnit','MU:Byte']])
    m.defMetric('packet_time_s', :integer, 'Time the packet was processed (s)')
    m.defMetric('packet_time_us', :integer, 'Time the packet was processed (us)')
    m.defMetric('packet_sent_time_s', :integer, 'Time the packet was sent (s) for datagram-oriented protocols',[['MD:Iperf','MD:hasMeasurementData','MD:OneWayDelayMeasurement'],['MD:OneWayDelayMeasurement','MD:OneWayDelayMeasurementValue','%value%'],['MD:OneWayDelayMeasurement','MD:defaultUnit','MU:second']])
    m.defMetric('packet_sent_time_us', :integer, 'Time the packet was sent (us) for datagram-oriented protocols',[['MD:Iperf','MD:hasMeasurementData','MD:OneWayDelayMeasurement'],['MD:OneWayDelayMeasurement','MD:OneWayDelayMeasurementValue','%value%'],['MD:OneWayDelayMeasurement','MD:defaultUnit','MU:microsecond']])
  }

end

# Local Variables:
# mode:ruby
# End:
# vim: ft=ruby:sw=2
